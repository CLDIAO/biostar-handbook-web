{% extends "unitbase.html" %}
{% load pytags %}
{# title =  GriffithLab RNA-Seq #}
{# subtitle = transcriptome analysis in the cloud #}
{# name = Informatics for RNA-seq: A web resource for analysis on the cloud #}

{% block body %}

{% markdown %}

### Informatics for RNA-seq: A web resource for analysis on the cloud

This tutorial is based on the paper:

* [Malachi Griffith*, Jason R. Walker, Nicholas C. Spies, Benjamin
J. Ainscough, Obi L. Griffith*. 2015.
Informatics for RNA-seq: A web resource for analysis on the cloud. 11(8):e1004393.
PLoS Computational Biology][pcbi.1004393]

[pcbi.1004393]: http://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.1004393

The Github repository for the original tutorial can be found at: https://github.com/griffithlab/rnaseq_tutorial

- - -

### Install the data

Install the data as described in {% link "uhr-hbr-data.html" %}

Note that while we use the data published in the publication above
the data naming and content
has been simplified.

Note: we have moved annotations to genome build hg38

- - -

### Simple alignment with bwa

While bwa was not originally designed as a spliced aligner the bwa mem method works suprisingly well.

	# The bam conversion shortcut.
	alias bam='samtools view -b - | samtools sort -o - booyah'

	# Set up some variables. These allow you to see the differences between invoking
	# different tools

	# Reference genome
	REF=annot/refs/22_ERCC92.fa

	# Reference annotations
	GTF=annot/refs/22_ERCC92.gtf

	# The index to store under.
	IDX=annot/refs/22_ERCC92

	# Shortcut to the reads
	R1=data/UHR_Rep1.R1.fq
	R2=data/UHR_Rep1.R2.fq

	# Build a bowtie2 index.
	bowtie2-build $REF $IDX

	# If you have hisat2 build index
	# with that as well.
	hisat2-build $REF $IDX

	# Also create a samtools index.
	samtools faidx $REF

Now run Tophat (or HiSat2) on the same dataset:

	# Run a tophat with no external information.
	tophat2 -o tophat-simple $IDX $R1 $R2
	samtools index tophat-simple/accepted_hits.bam

	# Often it is hard to see where you have data. It is handy to build
	# a coverage file (bedgraph)
	bedtools genomecov -ibam tophat-simple/accepted_hits.bam -g $REF.fai -split -bg > tophat-simple/accepted_hits.bedgraph

	# Bedgraph is inefficient for large files, what we typically use ar bigWig files
	# that are built to load
	bedGraphToBigWig tophat-simple/accepted_hits.bedgraph $REF.fai tophat-simple/accepted_hits.bw

	# You can also run hisat to produce alignments
	hisat2-align-s $IDX -1 $R1 -2 $R2 | bam > tophat-simple/hisat.bam; samtools index tophat-simple/hisat.bam

Above we ran tophat in its simplest form. Just index and data. Tophat
generates a large number of outputs. Investigate those and look at what
files it has created. Results go into the `tophat-simple` folder.
Each run of tophat generates an entire folder.

Now run tophat with with annotations.

	tophat2 -o tophat-annot -G $GTF $IDX  $READ1 $READ2
	samtools index tophat-annot/accepted_hits.bam

Run tophat after adding all known information, and instruct it to align to genome and
transcriptome.

	# Also setting up a transcriptome based alignment
	GROUP=somegroup
	SAMPLE=somesample
	OUTPUT=tophat-best
	TRANSDIR=transdir

	# Factor out the variable regions from the command
	# You can then override those and rerun the command
	tophat2 -p 2 -r 60 --library-type fr-firststrand -o $OUTPUT --rg-id=$GROUP --rg-sample=$SAMPLE --transcriptome-index $TRANSDIR -G $GTF $IDX $READ1 $READ2
	samtools index tophat-best/accepted_hits.bam

Here is an IGV view of the results:


### Generate alignments

This can be very tedious. Two strategies:

1. List each command separately and save it into a file.

2. Find the common parts of each command and factor it out into variables

There are several way to go about it, you can create a script or an alias that does the work once the
variables are filled in

	# Set up a shortcut to the command
	# Sometimes this is the hardest to figure out. What parts of the command are common?
	alias megaton='tophat2 -p 4 -r 60 --library-type fr-firststrand -o $LABEL --rg-id=$LABEL --rg-sample=$LABEL --transcriptome-index $TRANSDIR -G $GTF $IDX data/$LABEL.r1.fq data/$LABEL.r2.fq; samtools index $LABEL/accepted_hits.bam'

	# This will not change
	TRANSDIR=transdir

	# Replicate 1
	LABEL=UHR_Rep1_Mix1
	megaton

	# Replicate 2
	LABEL=UHR_Rep2_Mix1
	megaton

	# Replicate 3
	LABEL=UHR_Rep3_Mix1
	megaton

The same for the `HBR` samples

	# Replicate 1
	LABEL=HBR_Rep1_Mix2
	megaton

	# Replicate 2
	LABEL=HBR_Rep2_Mix2
	megaton

	# Replicate 3
	LABEL=HBR_Rep3_Mix2
	megaton

At this point the alignment step is done. On to analysis.

### Differential expression

Depending on the quality and accuracty of the data

	~/src/cufflinks-2.1.1.OSX_x86_64/cuffdiff -p 4 -o cuffdiff $GTF UHR_Rep1_Mix1/accepted_hits.bam,UHR_Rep2_Mix1/accepted_hits.bam,UHR_Rep3_Mix1/accepted_hits.bam  HBR_Rep1_Mix2/accepted_hits.bam,HBR_Rep2_Mix2/accepted_hits.bam,HBR_Rep3_Mix2/accepted_hits.bam

Evaluate the results:

	cat gene_exp.diff  | cut -f 1,2,10,13 | head

	# Sort by fold change and keep only lines that pass
	# The word "yes" is listed if the q-value passes a treshold
	cat gene_exp.diff  | grep yes | sort -k10,10 -rn | cut -f 1,3,4,10,13 | head -3

Produces:

	gene:ENSG00000130540	SULT4A1	7.60112	0.0158178
	gene:ENSG00000186732	MPPED1	6.38913	0.00242042
	gene:ENSG00000008735	MAPK8IP2	5.65319	0.000135811

Do a litle work to investigate how the values for `SULT4A1` might have been produced:

	cat annot/refs/22_ERCC.gff3 | grep SULT

	# data for one transcript
	cat annot/refs/22_ERCC.gff3 | grep ENST00000330884

	# Put the data into sut4.gff
	cat annot/refs/22_ERCC.gff3 | grep ENST00000330884 > sult4.gff


Set up even more shortcuts:

	u1=UHR_Rep1_Mix1/accepted_hits.bam
	u2=UHR_Rep2_Mix1/accepted_hits.bam
	u3=UHR_Rep3_Mix1/accepted_hits.bam

	h1=HBR_Rep1_Mix2/accepted_hits.bam
	h2=HBR_Rep2_Mix2/accepted_hits.bam
	h3=HBR_Rep3_Mix2/accepted_hits.bam


This simplifies running a coverage:

	bedtools multicov -bams $u1 $u2 $u3 $h1 $h2 $h3 -bed sult4.gff

	# Cut out only some of the columns
	bedtools multicov -bams $u1 $u2 $u3 $h1 $h2 $h3 -bed sult4.gff | cut -f 1,3-8,10-16


{% endmarkdown %}

{% endblock %}